require 'active_model'
require 'active_model/form/attribute_assignment'
require 'active_model/form/version'
require 'active_support/inflector'

module ActiveModel
  class Form
    include ActiveModel::Form::AttributeAssignment
    include ActiveModel::Validations
    include ActiveModel::Conversion
    include ActiveModel
    extend ActiveModel::Naming

    def initialize(attributes=nil)
      self.assign_attributes attributes
    end

    # For the Rails route helpers
    def persisted?
      false
    end

    # Set the model name to change the field names generated by the Rails form helpers
    def self.model_name=(name)
      @_model_name = ActiveModel::Name.new(self, nil, name)
    end

    def self.attribute(name, type_name)
      # TODO: Make inheritance of ActiveModel::Forms do the right thing with attributes
      @_attributes ||= {}
      @_attributes[name.to_sym] = self.type_from_type_name(type_name)
      self.send(:attr_accessor, name)
    end

    def self.attributes
      @_attributes ||= {}
    end

    # Returns the class object for the named attribute.
    def class_for_attribute(name)
      self.class.attributes[name.to_sym]
    end

    # Stolen from ActiveRecord attribute_assignment.rb
    def attributes=(new_attributes, options={})
      return if new_attributes.blank?

      attributes = new_attributes.stringify_keys
      multi_parameter_attributes = []

      attributes.each do |k, v|
        if k.include?("(")
          multi_parameter_attributes << [ k, v ]
        elsif respond_to?("#{k}=")
          if v.is_a?(Hash)
            raise(UnknownAttributeError, "ActiveModel::Form doesn't deal with nested attributes for now: #{k}")
          else
            send("#{k}=", v)
          end
        else
          raise(UnknownAttributeError, "unknown attribute: #{k}")
        end
      end
    end

    private

    # Stolen from ActiveRecord attribute_assignment.rb
    # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
    # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
    # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate
    # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the
    # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum,
    # f for Float, s for String, and a for Array. If all the values for a given attribute are empty, the
    # attribute will be set to nil.
    def assign_multiparameter_attributes(pairs)
      execute_callstack_for_multiparameter_attributes(
        extract_callstack_for_multiparameter_attributes(pairs)
      )
    end



    protected

    def self.type_from_type_name(type_name)
      classified_type_name = ActiveSupport::Inflector.classify(type_name)
      ActiveSupport::Inflector.safe_constantize(classified_type_name)
    end
  end
end
